{{#> layout.page
    title="Boring web frontend development"
    view="boring-web-frontend-development"
}}
    <retro-content-block data-date="2025-02-01">
        <span slot="title">Boring web frontend development</span>
    </retro-content-block>

    <p>
        The web frontend field is exciting. Perhaps even too exciting. Every seasoned frontend engineer has gone through at least one
        existential crisis due to the ever-changing environment and plethora of strange tools.
    </p>
    <p>
        That doesn't really make sense. Fundamental technologies - HTML, CSS, and Javascript - are boring. They evolve slowly, they're
        always backwards compatible, and they never change core principles. These technologies don't even require any development
        environment. Find a way to write and edit a text file on a PC, and you're all set.
    </p>
    <p>
        In this hectic digital world, we can benefit from boredom. That's why I'll try, like every proper frontend developer, of course,
        to build a tool for web frontend development.
    </p>
    <p>This boring tool will try to follow these principles:</p>
    <ul>
        <li>A native feel, focusing on core technologies rather than the tool itself.</li>
        <li>A strict architecture that makes the codebase predictable and, yes, boring.</li>
        <li>A pleasant and modern build system that enables the development of production-ready web interfaces.</li>
    </ul>

    <h3 id="native-feel">Native feel</h3>
    <p>
        What does it mean for a tool to have a native feel? In this case, code produced by programmers should not be drastically different
        from that executed on the client side - developers using this tool should write almost pure CSS, HTML, and Javascript.
    </p>
    <p>
        However, to build a practical tool, a thin layer of abstraction is needed. The goal is to produce code that has a decent level of
        cross-browser compatibility, performs well, and fails properly, all that whilst providing a decent experience.
    </p>
    <p>
        For some scenarios, it's worth adding more concrete abstractions. For example, I'll introduce <a href="https://lit.dev" target="_blank">lit.dev</a> for
        the development of web components to reduce boilerplate code.
    </p>
    <p>
        Another example would be HTML. It's pretty sweet, but it lacks basic logic to promote reusability through templates - during the build time, at least.
        For that reason, I'll add <a href="https://handlebarsjs.com/" target="_blank">Handlebars</a>, so developers are able to organise the code properly.
    </p>
    <p>
        Last but not least, what about the user experience in the web browser? The industry has completed the whole cycle from only using SSR to preferring SPAs.
        The conclusion is that SSR should be preferred for performance reasons, while SPAs have their place in highly dynamic apps. Since this is a tool for
        general web development, I'll go with the SSR approach. I'll skip backend logic for now, and leave routing to the plain old HTTP server.
    </p>
    <blockquote>
        In the future, the plan is to integrate the tool with something like Django to enable logic on the backend, e.g. for user sessions.
    </blockquote>

    <h3 id="architecture">Architecture</h3>

    * Predictable architecture is good architecture. For both individual and team projects.
    * This tool will try to force an architecture where every app is divided into two high-level parts: views and library.

    * Views are points of contacts with users. To speak in industry terms, views are of interest to business stakeholders and product managers.
    * On the other hand, a library is a set of UI components, small utilities, services, and all other units that are needed to achieve desired functionality.

    * One advantage of this approach is to put users in the focus. Views must be clear and readable, because they define what users can see and do. While libraries are for nerds that develop these apps and understand all the small parts required by the engine.

    * Note: to ensure structure, this boring tool foces a strict file structure and naming conventions.

    <h3 id="build-system">Build system</h3>

    * Build system - the most boring part of the tool. A good build system should be invisible while providing development, test, and build actions.
    * I'll try to keep configuration to minimum, while the tool will except naming conventions and folder structure regarding views, components and tests.

    <h3>In practice</h3>

    To sum all of the above, I've built a small boring tool, Revizor, with which I built this website.
    
    The goal was to create a reusable set of helpers that can be used in other projects. Although I'm not sure if the goal was achieved.

    Revizor is currently placed in a separate folder inside a repository of retrovizor.xyz.
{{/layout.page}}

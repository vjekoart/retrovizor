{{#> layout.page
    title="Boring web frontend development"
    view="boring-web-frontend-development"
}}
    <retro-content-block data-date="2025-02-01">
        <span slot="title">Boring web frontend development</span>
    </retro-content-block>

    <p>
        The web frontend field is exciting. Perhaps even too exciting. Every seasoned frontend engineer has gone through at least one
        existential crisis due to the ever-changing environment and plethora of strange tools.
    </p>
    <p>
        That doesn't really make sense. Fundamental technologies - HTML, CSS, and Javascript - are boring. They evolve slowly, they're
        always backwards compatible, and they never change core principles. These technologies don't even require any development
        environment. Find a way to write and edit a text file on a PC, and you're all set.
    </p>
    <p>
        In this hectic digital world, we can benefit from boredom. That's why I'll try, like every proper frontend developer, of course,
        to build a tool for web frontend development.
    </p>
    <p>This boring tool will try to follow these principles:</p>
    <ul>
        <li>A native feel, focusing on core technologies rather than the tool itself.</li>
        <li>A strict architecture that makes the codebase predictable and, yes, boring.</li>
        <li>A pleasant and modern build system that enables the development of production-ready web interfaces.</li>
    </ul>

    <h3 id="native-feel">Native feel</h3>
    <p>
        What does it mean for a tool to have a native feel? In this case, code produced by programmers should not be drastically different
        from that executed on the client side - developers using this tool should write almost pure CSS, HTML, and Javascript.
    </p>
    <p>
        However, to build a practical tool, a thin layer of abstraction is needed. The goal is to produce code that has a decent level of
        cross-browser compatibility, performs well, and fails properly, all that whilst providing a decent experience.
    </p>
    <p>
        For some scenarios, it's worth adding more concrete abstractions. For example, I'll introduce <a href="https://lit.dev" target="_blank">lit.dev</a> for
        the development of web components to reduce boilerplate code.
    </p>
    <p>
        Another example would be HTML. It's pretty sweet, but it lacks basic logic to promote reusability through templates - during the build time, at least.
        For that reason, I'll add <a href="https://handlebarsjs.com/" target="_blank">Handlebars</a>, so developers are able to organise the code properly.
    </p>
    <p>
        Last but not least, what about the user experience in the web browser? The industry has completed the whole cycle from only using SSR to preferring SPAs.
        The conclusion is that SSR should be preferred for performance reasons, while SPAs have their place in highly dynamic apps. Since this is a tool for
        general web development, I'll go with the SSR approach. I'll skip backend logic for now, and leave routing to the plain old HTTP server.
    </p>
    <blockquote>
        In the future, the plan is to integrate the tool with something like Django to enable logic on the backend, e.g. for user sessions.
    </blockquote>

    <h3 id="architecture">Architecture</h3>
    <p>
        Good architecture is predictable architecture. For both individual and team projects. This tool will try to force an architecture where every app is
        divided into two high-level concepts: views and a library.
    </p>
    <p>
        Views are points of contact for users. To speak in industry terms, views are of interest to business stakeholders and product managers. They define
        what users can see and do with the application. On the other hand, a library is a set of UI components, small utilities, services, and all other units that are
        needed to achieve complete functionality.
    </p>
    <p>
        The main idea behind this approach is to put users at the forefront. Views are clear and readable because they define the most important part of the application.
        But libraries, they are for nerds. They can handle messy code - complex utility functions that will get their comments and well-deserved refactors some day.
    </p>
    <blockquote>
        To enforce an architecture, this tool expects specific file structure and naming conventions.
    </blockquote>

    <h3 id="build-system">Build system</h3>
    <p>
        The build system - the most boring part of the tool.
    </p>
    <p>
        A good build system should be invisible, while providing development, test, and build actions.
    </p>
    <p>
        The goal is to cover all aspects of testing, from unit tests to complex in-browser E2E tests.
    </p>

    <h3>In practice</h3>
    <p>
        To sum all of the above, I've built a small boring tool called <a href="https://github.com/vjekoart/retrovizor/tree/master/revizor" target="_blank">Revizor</a>, with which I built this website.
    </p>
    <p>
        The idea was to create a reusable set of helpers inspired by the principles outlined at the beginning of this text. Although I'm not sure if the goal was achieved.
    </p>
    <p>
        Revizor is currently placed in a <a href="https://github.com/vjekoart/retrovizor/tree/master/revizor" target="_blank">separate folder</a> inside the repository of retrovizor.xyz.
    </p>
{{/layout.page}}
